---
layout: post
title: '单调队列 学习笔记'
subtitle: '代码简单但是可以打出骚操作的数据结构'
date: 2018-01-20
categories: OI
cover: 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2256594211,3526564754&fm=27&gp=0.jpg'
tags: 单调队列
---
# [单调队列 学习笔记](http://www.cnblogs.com/Jason-Damon/archive/2012/04/19/2457889.html)
## 什么是单调队列
单调队列是一种队中元素单调递增或者递减的元素。单调队列包括两个限定条件：大小和时间。也就是说，队中元素除了大小要单调之外，也会有一定的时间（即数组的下标）限制，超时的元素不能存在在队列中（不过有的题目没有对于时间的限制）。
## 单调队列的实现
单调队列是一种很活的数据结构，但实现这种数据结构无非需要两步：
### 踢出队首元素
把超时的队首元素从队列中踢出去。
```cpp
    while (q[head]<i-w+1) head++;
```
### 补进队尾元素
这里以维护单调递增队列为例。
```cpp
    while (head<=tail && a[q[tail]]>a[i]) tail--;
```
### 备注
这样的语句不是固定的，针对不同的题目可以做不同的修改。
## 单调队列例题
### [luogu1886 滑动窗口](https://www.luogu.org/problemnew/show/P1886)
先上一道板子。    
把这个意象一下，就是一个数据流在流动，然后窗口是固定的。然后可以在窗口内分别维护单调递增和单调递减的序列。    
具体看代码注释。    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int head,tail,q[1000005],ansmin[1000005],ansmax[1000005],a[1000005],n,w;
int read()
{
    char c;int r;int f=1; 
    c=getchar();
    if (c=='-') f=-1;
    while (c<'0' || c>'9')
    {
        c=getchar();
        if (c=='-') f=-1;
    }
    r=0;
    while (c>='0' && c<='9')
    {
        r=r*10+c-'0';
        c=getchar();
    }
    r*=f;
    return r;
}
void getmax()
{
    memset(q,0,sizeof(q));
    head=1;tail=1;
    ansmax[1]=a[1];
    q[head]=1;
    for (int i=2;i<=n;i++)
    {
        while (q[head]<=i-w && q[head]!=0) head++;//当前队首不在滑动窗口里面，出队
		while (head<=tail && a[q[tail]]<a[i]) tail--;//如果当前队尾比i小,出队 
        q[++tail]=i;//i入队 
        ansmax[i]=a[q[head]];
        //因为此时的队列已经维护完毕，只剩下比i大而且没过期的了，而且队首肯定是最大的，不然早被踢掉了 
    }
}
void getmin()
{
    memset(q,0,sizeof(q));
    head=1;tail=1;
    ansmin[1]=a[1];
    q[tail]=1;//点1入队 
    for (int i=2;i<=n;i++)
    {
		while (q[head]<=i-w && q[head]!=0) head++;//当前队首不在滑动窗口里面，出队 
        while (head<=tail && a[q[tail]]>a[i]) tail--;//如果当前队尾比i大,出队 
        q[++tail]=i;//i入队 
        ansmin[i]=a[q[head]];
        //因为此时的队列已经维护完毕，只剩下比i小而且没过期的了，而且队首肯定是最小的，不然早被踢掉了 
    }
}
int main()
{
    n=read();w=read();
    for (int i=1;i<=n;i++) a[i]=read(); 
    getmin();
    getmax();
    for (int i=w;i<=n;i++) printf("%d ",ansmin[i]);
    printf("\n");
    for (int i=w;i<=n;i++) printf("%d ",ansmax[i]);
    printf("\n");
} 
```
### [luogu1714 切蛋糕](https://www.luogu.org/problemnew/show/P1714)
一道水题，然而花了我好半天。    
一开始的漏洞思维不想多说，说一下正解。
这个题就是找一对前缀和，然后让这对前缀和的差最大就好了。但是这对前缀和要在一定的范围内，而且队列里面的前缀和显然是越小越好，所以比起当前的，又老又大的直接踢掉就行了。所以维护一个单调递增序列就能实现了。
```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <cstring>
#define rint register int
using namespace std;
int n,m,sum[1000100],f[1000100],ans=-2100000000;
int q[1000010],head=1,tail=0;
int main(){
   	
    cin>>n>>m;
    for (rint i=1;i<=n;i++)
    {
    	int a;
        scanf("%d",&a);
        sum[i]=sum[i-1]+a;
    }
    for (rint i=1;i<=n;i++)
    {
        while (q[head]<=i-m) head++;
        ans=max(ans,sum[i]-sum[q[head]]);
        while (sum[q[tail]]>sum[i] && head<=tail) tail--;
        q[++tail]=i;
    }
    printf("%d\n",ans);
}
```
### TO BE CONTINUED
